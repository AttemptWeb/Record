
**在现代操作系统中，进程支持多线程。进程是资源管理的最小单元；而线程是程序执行的最小单元。
一个进程的组成实体可以分为两大部分：线程集合、资源集.进程中的线程是动态的对象;代表了进程指令的执行.**
>资源, 包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。 

>线程有自己的私有数据：程序计数器，栈空间以及寄存器。

### 多线程的优缺点
      支持多线程的程序(进程)可以取得真正的并行(parallelism)，且由于共享进程的代码和全局数据,故线程间的通信是方便的。
    它的缺点也是由于线程共享进程的地址空间，因此可能会导致竞争，因此对某一块有多个线程要访问的数据需要一些同步技术。
    
### 三种线程——内核线程、轻量级进程、用户线程
* 内核线程
>内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步/IO 时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核(Multi-Threads kernel )。

* 轻量级进程
>轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。每一个进程有一个或多个LWPs，每个LWP由一个内核线程支持。这种模型实际上就是恐龙书上所提到的一对一线程模型。在这种实现的操作系统中，LWP就是用户线程。由于每个LWP都与一个特定的内核线程关联，因此每个LWP都是一个独立的线程调度单元。即使有一个LWP在系统调用中阻塞，也不会影响整个进程的执行。
> **轻量级进程具有局限性。首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。**  系统调用的代价相对较高：需要在user mode和kernel mode中切换。其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的LWP。

![image](https://raw.githubusercontent.com/Herryheng/Knowledge/master/Img/LWP.jpg)

      1.LWP的术语是借自于SVR4/MP和Solaris 2.x。
      2.有些系统将LWP称为虚拟处理器。
      3.将之称为轻量级进程的原因可能是：在内核线程的支持下，LWP是独立的调度单元，
      就像普通的进程一样。所以LWP的最大特点还是每个LWP都有一个内核线程支持。
* 用户线程
>LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。

![image](https://raw.githubusercontent.com/Herryheng/Knowledge/master/Img/Uthread1.JPG)

>上图是最初的一个用户线程模型，从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。用户线程之间的调度由在用户空间实现的线程库实现。
这种模型对应着恐龙书中提到的 **多对一线程模型** ， **其缺点是一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞**。

* 加强版的用户线程——用户线程+LWP
>
