# 计算模型 DSA 
    Data Structures + Algorithms +  = Program 
    
## 问题规模
**算法分析**

* 正确性 ：算法功能与问题一致
* 成本 ： 运行时间 + 存储空间
        (如何度量、如何比较)

考察: Ta(P) = 算法a求解问题实例P的计算成本
    意义不大，毕竟出现的问题实例不同
    ·如何归纳概括？ ==》 划分等价类

2、观察：问题实例的规模，往往是决定计算成本的主要因素（一般）

3、通常：问题规模越接近，计算的成本也越接近，规模越大，计算成本亦上升

## 最坏情况
**特定问题 + 不同实例**

令Ta(n) = 用算法A求解某一问题规模为n的实例，所需计算成本讨论特定算法A时，简记T(n)；

* 观察：同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别

如何定义T(n)?

稳妥起见，取T(n) = max{ T(P) || |P| = n},在同等规模中，只关注最坏情况（成本最高）

## 理想模型
**特定问题 + 不同算法**

不同算法可能适合的不同规模的输入

不同算法可能适应不同的类型的输入

同一算法可能有不同程序猿用不同语言、不同编译器实现

同一算法，可能实现运行于不同的体系结构、操作体系

为给出**合理**的结果，所以需要抽象出一种理想的平台或模型

## TM 图灵模型

* Tape（纸带）: 依次均匀的划分为单元格，各注有某一字符，默认为‘#’

* Alphabet（字符表） 字符的种类有限
 
* Head（读写头） 总是对准某一单元格，并可读取和改变其中的字符，每经过一个节拍，可(按照规则)转向左侧或右侧的邻格.

* state 重视处于有限种状态中的某一种每经过一个节拍，可转向另一种状态(有限种可能的状态)

* Transition  Function:(q,c,d,L/R,p) 后三项动作
当前状态为q且当前字符c，则将当前字符改变，一但转入特定的状态‘h’，即停机

## RAM模型 Random Access Machine
寄存器

寄存器常数赋值语句 R[i] <- c  

寄存器赋值语句 R[i] <- R[j]

间接取值 R[i] <- R[R[j]]

寄存器加减   R[i] <- R[j] + R[k]    R[i] <- R[j] - R[k]

条件判断 IF R[i] = 0 GOTO 1     IF R[i] > 0 GOTO 1    顺序 GOTO 1     终止语句 STOP

与TM模型一样，都是一般计算工具的简化和抽象

算法运行时间 ==》 算法的执行的基本操作次数