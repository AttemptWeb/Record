# 我被闭包啪啪啪的打脸了

尴尬了，遇到了一个闭包的问题，然后我说错了答案，装逼失败了，之前我以为自己完全理解了闭包，现在发现其实并没有,赶紧翻书找答案ing。

看下面的代码，在循环中向数组导入函数, 希望可以打印```0，1，2```:
```javascript
function func() {
    var arr = [];
    for(var i = 0;i<3;i++){
        arr.push(()=> {
            console.log(i);
        })
    }
    return arr
}
var result = func();
result.forEach((item)=> {
    item();
})

<!-- 打印信息 三个3 -->
// 3
```
发现打印的都是3，原因是匿名函数中的```i```共享了同一个词法作用域 。当变量数组调用匿名函数时, **var** 声明的变量不存在块级作用域, ```i``` 的值已经指向了```for```循环 ```i``` 的最后一项。

## 解决上面的问题

使用```let```或者```闭包```可以解决上面的问题

解决代码：
```javascript
<!-- 方案一 -->
// 使用let 声明变量
function func() {
    var arr = [];
    for(let i = 0;i<3;i++){
        arr.push(()=> {
            console.log(i);
        })
    }
    return arr
}
var result = func();
result.forEach((item)=> {
    item();
})

<!-- 方案二 -->
// 使用闭包
function func() {
    var arr = [];
    for(var i = 0;i<3;i++){
        (function(){
            arr.push(()=> {
                console.log(i);
            })
        })()
    }
    return arr
}
var result = func();
result.forEach((item)=> {
    item();
})
```
以为已经解决了, 没想出了其他问题！可以运行一下上面的方案一和方案二, 你会发现方案二的结果是打印出了**三个3**. WT？不是应该**打印0、1、2**, 怎么没有? 

## 闭包执行上下文产生的作用域链

方案一中当然是没有问题的，使用```let```解决作用域问题。在方案二中, 使用闭包解决变量```i```的作用域问题,但是好像闭包失效了？

在方案二中**闭包的作用是变量私有化，保存闭包执行作用域链，变量```i``不被销毁**。对于执行上下文不了解的可以查看**冴羽**的[JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)。而方案二中的输出的数字却不是我们想要的，究其原因，是我对闭包作用域不理解导致的。

方案三:
```javascript
function func() {
    var arr = [];
    for(var i = 0;i<3;i++){
        (function(i){
            arr.push(()=> {
                console.log(i);
            })
        })(i)
    }
    return arr
}
var result = func();
result.forEach((item)=> {
    item();
})
```
以上就是解决方案，将```i```加在匿名函数参数就解决了方案二的问题。下面来细说一下是怎么回事:

**为了方便描述**，我将 **自运行的匿名函数 简称为 ```fn1```, 而arr中的回调匿名函数 简称为 ```fn2```**。当然arr中的的三个函数分别是三个不同的```fn2函数```。

当调用```func函数```, ```函数fn1```自运行，变量```arr```被注入三个```fn2```函数，同时```arr```被```return```出来。此时形成了闭包作用域链。

闭包执行上下文作用域链
```javascript
fn1函数作用域链 : {
    fn1函数变量&&参数 , func函数变量&&参数 , 全局作用域变量
}

fn2函数作用域链 : {
    fn2函数变量和参数 , fn1函数变量&&参数 , func函数变量&&参数 , 全局作用域变量
}
```
```函数func```也就不写出来了。由以上可知```作用域链会保存局部变量、全局变量、函数参数```。在正常函数调用后，执行上下文之后作用域链被销毁，但是当存在闭包时，作用域链会被保存。

```arr中的fn2函数作用域```，就基本形成一个作用域链，作用域链是单向的，内部向外部查找，由下向上查找。

### 比较方案二 与 方案一

```javascript
// 方案二
function func() {
    var arr = [];
    for(var i = 0;i<3;i++){
        (function(){
            arr.push(()=> {
                console.log(i);
            })
        })()
    }
    return arr
}
```

那么现在再来看方案二: 数组```arr```中的```fn2函数```会先查找自身函数作用域，不存在i那么就向上继续查找，找到```func函数```下的```变量i```，将```i```打印出来，但此时```func函数```中的局部```变量i```已经等于3了, 由于```for```循环三次，```arr```中有三个```fn2函数```，所以打印了三次3。

```javascript
// 方案三
function func() {
    var arr = [];
    for(var i = 0;i<3;i++){
        (function(i){
            arr.push(()=> {
                console.log(i);
            })
        })(i)
    }
    return arr
}
```
而在方案三中。```arr```中的```fn2函数```会先查找自身函数作用域，不存在i那么就向上继续查找，找到```fn1函数```中参数```i```, 将i打印出来。 由于```for```循环三次，每次都是生成一个全新的函数，所以函数参数分别是0、1、2。

其实说到这里，基本可以了解，方案二中的问题，其实就是闭包作用域链的问题，当形成闭包时，闭包涉及到的作用域链会被保存。如果真正的了解了闭包，绝对不会遇见像我这样的问题，算是给我自己上了一课啰。写的不好的地方希望大家可以指出，下面是参考的文章链接。

参考: 

[MDN 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

[JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)

[JavaScript深入之闭包](https://github.com/mqyqingfeng/Blog/issues/9)
